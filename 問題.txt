傳值是把引數複製一份給參數
傳參考是把引數的記憶體地址給參數
	拷貝建構子的意義是Card b=a;(重點Card中沒有用到指標變數)拷貝建構子使ab兩物件有	相同的資料卻有不同的記憶體位址，而非像傳參照的形式使ab兩物件共用同一記憶體空	間。
拷貝建構子寫法:className (const className& other){內容}
	在Card b=a;時自動呼叫(用a初始化b)
	因為是建構子所以函式名稱和物件名稱一樣(className)
	other為a的參考
	所謂參考是指[]為[]變數的別名。特性有1.參考不是指標 2.改參考內容等於改變數 3. 	參考一旦建立，就永遠綁定那個變數。
	為什麼要加const?
	因為怕在建構函式中透過other修改a的屬性
	為什麼要用&傳參照的寫法?
	如果以className (const className other)建立拷貝建構子的話，傳值呼叫會導致程式	需要複製一個a給other，又會在呼叫一次建立拷貝建構子，最後導致錯誤。
拷貝指派運算子:className& operator=(const className& other){content}
	在當已經存在的物件被賦值時，便會呼叫拷貝指派運算子。
	例如；Card a={"zami",1,10};  Card b={"sarkaz",5,10}; b=a;
	函式宣告:className&
	className&運算子會回傳目前這個物件本身的參考（*this），以例子來說，便是回傳
	b的參考寫作*this。
	函式宣告:operator=
	讓=這個運算子在類別中有「你自己定義的意義」。(深層複製)
	函式宣告(const className& other)
	指定需要拷貝的對象做為參考。以例子來說，便是a的參考名為other，且只能讀入	(const)，用&的原因是因為傳參照方便，也能不用，不用的話便是傳值呼叫，需要呼叫	拷貝運算子把a複製給other。
	在實做檔的寫法中，因為拷貝指派運算子是一個具有回傳型別的運算子，所以應該要寫	作className& className::operator=(const className& other)。



	